<!DOCTYPE html>
<html lang="en-us">
    <head>
    <title>Drawing a directed graph with ASCII-characters in Emacs (Part 2) - Storax</title>
    <meta charset="utf-8" />
    <meta name="author" content="David Zuber" />
        <meta name="description" content="The ranking algortihm." />
        <meta name="keywords" content="Emacs,ascii,graph,emaci,lisp" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
</head>

    <body class="container">
        <div>
    <header class="masthead">
        <h1 class="masthead-title"><a href="/">Storax</a></h1>
        <p>Soon to be a major emacs mode.</p>
        <ul>
                <li><a href="/blog/">Blog</a></li>
            <li><a href="/tags/">Tags</a></li>
            <li><a href="/about/">About</a></li>
            <li><a href="https://github.com/storax">GitHub</a></li>
            <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="//www.google.com/search">
            <input type="text" class="field" name="q" id="s" placeholder="Search">
            <input type="hidden" name="as_sitesearch" value="storax.github.io">
        </form>
    </header>
</div>

        <div>
    <div class="post">
            <h1>Drawing a directed graph with ASCII-characters in Emacs (Part 2)</h1>
        <p>
In <a href="http://storax.github.io/blog/2016/05/29/drawing-a-directed-graph-with-ascii-characters-in-emacs/">part 1</a> I started researching on how to implement an algorithm for drawing directed graphs
in Emasc.
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">The ranking algorithm</h2>
<div class="outline-text-2" id="text-orgheadline1">
<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">rank</span> <span style="color: #BFEBBF;">()</span>
  <span style="color: #BFEBBF;">(</span>feasible-tree<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #D0BF8F;">(</span>e<span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">while</span> <span style="color: #93E0E3;">(</span>setq e <span style="color: #9FC59F;">(</span>leave-edge<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span>
      <span style="color: #93E0E3;">(</span>exchange e <span style="color: #9FC59F;">(</span>enter-edge e<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>normalize<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>balance<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
The ranking algorithm stats with finding a feasible tree
</p>
</div>
<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">feasible-tree</h3>
<div class="outline-text-3" id="text-orgheadline2">
<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">feasible-tree</span> <span style="color: #BFEBBF;">()</span>
  <span style="color: #BFEBBF;">(</span>init-rank<span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">while</span> <span style="color: #D0BF8F;">(</span>&lt; <span style="color: #93E0E3;">(</span>tight-tree<span style="color: #93E0E3;">)</span> <span style="color: #93E0E3;">(</span>absolute-value V<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span>
    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #93E0E3;">(</span><span style="color: #9FC59F;">(</span>e <span style="color: #94BFF3;">(</span>get-non-tree-node-incident-on-tree-with-min-slack<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span>
          <span style="color: #9FC59F;">(</span>delta <span style="color: #94BFF3;">(</span>slack e<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span>
      <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">when</span> <span style="color: #9FC59F;">(</span>eq incident-node <span style="color: #94BFF3;">(</span>e-head e<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span>
        <span style="color: #9FC59F;">(</span>setq delta <span style="color: #94BFF3;">(</span>- delta<span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span>
      <span style="color: #93E0E3;">(</span>mapc
       <span style="color: #9FC59F;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #94BFF3;">(</span>v<span style="color: #94BFF3;">)</span> <span style="color: #94BFF3;">(</span>setf <span style="color: #E0CF9F;">(</span>v-rank v<span style="color: #E0CF9F;">)</span> <span style="color: #E0CF9F;">(</span>+ <span style="color: #8FB28F;">(</span>v-rank v<span style="color: #8FB28F;">)</span> delta<span style="color: #E0CF9F;">)</span><span style="color: #94BFF3;">)</span><span style="color: #9FC59F;">)</span>
       tree<span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span>
  <span style="color: #BFEBBF;">(</span>init-cutvalues<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
Remember <code>v</code> is a node, <code>e</code> is an edge. Rank is the the level of a node in the graph.
A tight edge has the slack 0. So if the minimal length of an edge is 1, then
the slack is calculated by <code>(- (length e) minimal-length)</code> so an edge with length 1 would have a slack of zero,
thus being tight.
</p>
</div>

<div id="outline-container-orgheadline3" class="outline-4">
<h4 id="orgheadline3">init-rank</h4>
<div class="outline-text-4" id="text-orgheadline3">
<p>
The paper won't go into detail for brevity (sigh).
They use a queue.
You go through all nodes and place a node in the queue when they have no unscanned in-edges.
So the first nodes would be the ones without any in-edges.
</p>
<pre class="example">
a -- b -- d
  \-----/
</pre>
<p>
In the above graph a has no unscanned in-edges. All edges so far are unscanned.
So we assign a rank that satisfies the in-edges. Since there are no edges, we use 0.
Then we mark the outedges as scanned:
</p>
<pre class="example">
a0 == b -- d
 \========/
</pre>
<p>
So an equal sing declares an edge as marked. <code>a</code> has been assigned rank 0.
We check our remaining nodes for candidates for the queue.
<code>d</code> has an unscanned in-edge (<code>b--d</code>). But <code>b</code> is good.
So we assign <code>b</code> a rank that satisfies the in edges.
The edge connects to <code>a</code> wich already has a rank 0. So to satisfy it <code>b</code> gets 1.
Then we mark out-edges as scanned.
</p>
<pre class="example">
a0 == b1 == d
 \=========/
</pre>
<p>
Now d has no unscanned in-edges anymore so we put it in the queue.
On in edge goes to <code>a</code> which has rank 0 and one goes to <code>b</code> with rank 1.
So to satisfy both we need the maximum plus 1. So <code>d</code> gets rank 2.
The final result of <code>init-rank</code> is:
</p>
<pre class="example">
a0 == b2 == d3
 \=========/
</pre>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-4">
<h4 id="orgheadline4">tight-tree</h4>
<div class="outline-text-4" id="text-orgheadline4">
<p>
So according to the paper <code>tight-tree</code> finds a maximal tree of tight edges containing some fixed node
and returns the number of nodes in the tree.
So for this we disregard directions and use an undirected graph.
We choose a random node, e.g. <code>a</code>, and traverse the tree in all directions using tight edges.
</p>
<pre class="example">
a -- b -- c -- d -- f -- g
 \        i --/         /
  \----------- h ------/
</pre>
<p>
Not sure if this is what the paper means exactly. I guess my example would not occur
after <code>init-rank</code> but whatever.
So we pick a random node <code>a</code>. Using only tight edges <code>--</code> the tight tree is:
</p>
<pre class="example">
a -- b -- c -- d -- f -- g
          i --/
</pre>
<p>
<code>h</code> is not part of the tight tree.
When the number of nodes in the tight tree is the same as number of nodes in the graph,
the while loop terminates. Then every node is connected to another by at least one
thight edge.
</p>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-4">
<h4 id="orgheadline5">while body</h4>
<div class="outline-text-4" id="text-orgheadline5">
<p>
We take a non tree edge incident on the tree with minimal slack.
Allright, so we check each edge of our tree nodes and see if they go to a node that's not in the tree.
<code>a -- b</code> is a tree edge but <code>a -- h</code> is not. The slack is 2 (length is 3, minus minimal lenght 1 equals 2).
<code>h -- g</code> is also not a tree edge but the slack is 1 (length is 2, minus minimal length 1 equals 1).
So we take the edge with minal slack <code>h -- g</code>.
<code>delta</code> is the slack value 1.
If the incident node is the head, delta should be inverted.
The incident node is <code>g</code> (I guess) and it's the head.
So the rank of all nodes in the tree is decreased by 1.
</p>
<pre class="example">
a -- b -- c -- d -- f -- g
 \        i --/         /
  \---------------- h -/
</pre>
<p>
As we can see, <code>h</code> is now connected with a tight edge to <code>g</code>.
Also note that <code>a</code> has a rank of <code>-1</code>. That's why we need to normalize the graph afterwards.
Now all nodes are in the tight tree. We can caluclate this faster by
taking the tight-tree of <code>h</code> before the move and adding all the nodes to the tight tree.
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6">init-cutvalues</h4>
<div class="outline-text-4" id="text-orgheadline6">
<p>
This took a while until I fully understood what the paper was trying to say.
Also it's gonna get complicated calculating this without a very dumb algorithm.
The paper has some suggestions but they seem more complex than the other stuff.
</p>

<p>
So this computes the cut values of tree edges.
We iterate over the edges and mark nodes belonging to the head or tail component.
It's important that we keep in mind, which edges are tree edges.
Consider a graph like this
</p>
<pre class="example">
a =3= b =3= c =3= d =3== h
 \--------- f =0= g =-1=/
  \-------- e =0=/
</pre>
<p>
where the numbers indicate the cut values.
How does it work.
We cut the graph at an edge. Let's take <code>g--h</code>.
We have a head component starting from <code>h</code>:
</p>
<pre class="example">
a == b == c == d == h
</pre>
<p>
and the tail component
</p>
<pre class="example">
f == g
e ==/
</pre>
<p>
Now we sum the signed weight of all edges that have head and tail in different components.
The sign is negative for edges going from the head component to the tail.
So the first edge that has head and tail in different components is the edge we just cut.
It goes from tail to head so the value so far is 1.
But edges <code>a--f</code> and <code>a--e</code> also have head and tail in different components.
They go from the head component to the tail component.
So we have to negate their weights. The final sum and cut value is <code>1+(-1)+(-1)=2</code>.
So with our two cut components, any edge from head to tail is considered as
the edge from <code>enter-edge</code> (see pseudo code of rank algorithm).
So between <code>a--f</code> and <code>a--e</code> the one with the minimal slack is chosen. Both have the same slack
so we choose at random <code>a--e</code>.
The edges are exchanged so <code>g--h</code> now has the length of 2 and <code>a--e</code> 1.
Note that <code>g--h</code> and <code>a--f</code> are not part of the tree but <code>a--e</code> is.
Not quite sure yet how the exchange happends, but ranks have to be adjusted as well as the cut values.
The new rank of <code>e</code> has to be 0 (note that <code>a</code> is -1), same as f.
<code>g</code> is now of rank 1 instead of 2.
</p>
<pre class="example">
a ==2= b =2= c =2=d =2= h
 \---- f =0= g --------/
  \=1= e =1=/
</pre>
<p>
My guess is that the whole tail component is adjusted, by the amount of slack transfer.
I have to think about it more. But now it's 4 o'clock at night, so I'll sleep over it.
</p>

<p>
Good morning! Alright, so reading through the implementation details, we first should
cut values of edges connecting to a leaf node. It's trivial because either head or tail component has
only one node.
</p>
<pre class="example">
a -- b -- c -- d -- e
 \   f --/         /
  \---------------/
</pre>
<p>
So a leaf node is all nodes that have only 1 tight edge.
They can have non-tree edges.
If we cut the tight edge, either head or tail is only 1 node.
In this case <code>a--b</code>, <code>d--e</code> and <code>f--c</code>.
The cut value is calculated by looking at the edges connecting to the single node.
If the node is the tail, out-going edges are signed positive, in-going ones are negative.
If the node is the head, in-going edges are positive, out-going ones negative.
</p>
<pre class="example">
cutvalue = (if tail + else -) out-going + (if tail - else +) in-going.
</pre>
<p>
So with <code>f--c</code>, <code>f</code> is a tail node. That means outgoing ones are positive, giving it the value
of 1.
Cutting <code>a--b</code> will render <code>a</code> as a tail node. It has 2 outgoing edges so the cut value is 2.
When cutting <code>d--e</code>, e is a head node. This will make in going edges positive.
Since there are 2, the cut value is 2 as well.
</p>
</div>

<div id="outline-container-orgheadline7" class="outline-5">
<h5 id="orgheadline7">Optimization by using only local edges.</h5>
<div class="outline-text-5" id="text-orgheadline7">
<p>
The following part was a little bit confusing because it only showed the term
for one example. It did not give any rules, how the term was constructed.
The point the paper is trying to make is, that if you have a node, where
all cut values of tree edges are known, except for 1, you can calculate the cutvalue
with only looking at the edges connecting with that node.
The rules are the following:
</p>

<ul class="org-ul">
<li>start with the weight of the edge with unknown cut value (should be 1 in our case).</li>
<li>all non-tree egdes going out increment it by their weight (a.k.a. 1).</li>
<li>all non-tree edges going in decrement it by their weight.</li>
<li>for tree edges add their cut value but subtract their weight.</li>
</ul>

<p>
This works only when doing it incrementally.
We take the graph from above:
</p>
<pre class="example">
a === b == c == d == h
 \--- f == g -------/
  \== e ==/
</pre>
<p>
If we start with <code>h</code>, we could calculate the trivial solution and get 2.
Next we calculate another leaf <code>f</code> and get 0.
</p>
<pre class="example">
a === b === c == d =2= h
 \--- f =0= g --------/
  \== e ===/
</pre>
<p>
Now our incremental algorithm takes over.
We need a node with only 1 unkown tree edge.
<code>d</code> and <code>g</code> are good candidates.
Let's take <code>d</code> and calculate the unknown <code>c--d</code> cut value.
It has one tree edge with cut value 2 and weight 1.
Also we need the weight of <code>c--d</code> which is 1.
</p>
<pre class="example">
cut(c,d) = w(c,d) + cut(d,h) - w(d,h)
         = 1      + 2        - 1
         = 2
</pre>
<p>
Alright. Result is now this:
</p>
<pre class="example">
a === b === c =2= d =2= h
 \--- f =0= g ---------/
  \== e ===/
</pre>
<p>
Next we do the same with <code>c</code> and then <code>b</code> getting to this:
</p>
<pre class="example">
a =2= b =2= c =2= d =2= h
 \--- f =0= g ---------/
  \== e ===/
</pre>
<p>
Not time for <code>g</code>. The unknown edge is <code>e--g</code> with weight 1.
We have 1 outgoing non-tree edge and another tree edge.
</p>
<pre class="example">
cut(e,g) = w(e,g) + w(g,h) + cut(f,g) - w(f,g)
         = 1      + 1      + 0        - 1
         = 1
</pre>
<p>
Notice how outgoing non-tree edges are positive.
Weights of tree egdes are always negative while their cut value is positive.
</p>
<pre class="example">
a =2= b =2= c =2= d =2= h
 \--- f =0= g ---------/
  \== e =1=/
</pre>
<p>
Last but not least we look at <code>e</code> and the unknown edge <code>a--e</code>.
</p>
<pre class="example">
cut(a,e) = w(a,e) + cut(e,g) - w(e,g)
         = 1      + 1        - 1
         = 1
</pre>
<p>
Final initial cut values are:
</p>
<pre class="example">
a ==2= b =2= c =2= d =2= h
 \---- f =0= g ---------/
  \=1= e =1=/
</pre>

<p>
I hope this is correct. At least it's consistent with the paper. Not sure if it makes any sense,
but I feel like I understood it finally.
Sadly we are not done with optimizing.
</p>
</div>
</div>
<div id="outline-container-orgheadline8" class="outline-5">
<h5 id="orgheadline8">Optimization by labeling with postorder traversal</h5>
<div class="outline-text-5" id="text-orgheadline8">
<p>
It provides an inexpensive way to test, which nodes are in the head or in the tail.
It's important for knowing if a nontree edge crosses between the two components.
We do a postorder traversal starting from a fixed root node.
Each node gets labeld with <code>low(v)</code> and <code>lim(v)</code>.
We start with both being 1.
In a tree we always take the left branch first, labeling the node we pass with the current <code>low</code> and <code>lim</code>
values. The <code>low</code> will always stay set on the node.
Once we cannot go deeper, we have to go back inceasing current <code>low</code> and <code>lim</code> by one.
The next node we encounter get's set it's <code>lim</code> but not <code>low</code> because it's already set.
We continue doing that:
</p>
<pre class="example">
               (1,1)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     ( , )            ____( , )____
    /     \         _/      |      \_
   /       \       /        |        \
( , )     ( , ) ( , )     ( , )     ( , )
                  |
                  |
                ( , )

               (1,1)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,1)            ____( , )____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     ( , ) ( , )     ( , )     ( , )
                  |
                  |
                ( , )
</pre>
<p>
Now we reached a dead end, so we increase <code>low</code> and <code>lim</code>.
</p>
<pre class="example">
               (1,1)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,2)            ____( , )____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     ( , ) ( , )     ( , )     ( , )
                  |
                  |
                ( , )

               (1,1)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,2)            ____( , )____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     (2,2) ( , )     ( , )     ( , )
                  |
                  |
                ( , )
</pre>
<p>
Note that <code>low</code> never changed because it keeps the lowest value.
Another dead end so again increase <code>low</code> and <code>lim</code>.
</p>
<pre class="example">
               (1,4)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,3)            ____( , )____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     (2,2) ( , )     ( , )     ( , )
                  |
                  |
                ( , )
</pre>
<p>
We had to go up twice so <code>lim(root)</code> is now 4.
</p>
<pre class="example">
               (1,4)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,3)            ____(4,4)____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     (2,2) (4,4)     ( , )     ( , )
                  |
                  |
                (4,4)

               (1,4)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,3)            ____(4,6)____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     (2,2) (4,5)     ( , )     ( , )
                  |
                  |
                (4,4)

               (1,4)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,3)            ____(4,6)____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     (2,2) (4,5)     (6,6)     ( , )
                  |
                  |
                (4,4)

               (1,4)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,3)            ____(4,7)____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     (2,2) (4,5)     (6,6)     (7,7)
                  |
                  |
                (4,4)

               (1,9)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,3)            ____(4,8)____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     (2,2) (4,5)     (6,6)     (7,7)
                  |
                  |
                (4,4)
</pre>

<p>
So how do we determine head or tail components.
Let's take the edge with the node <code>(1,3)</code> to <code>(1,1)</code>.
Let's call them <code>u</code> and <code>v</code>.
Any node is in the tail component if and only if
</p>
<pre class="example">
low(u) less or equal lim(w) less or equal lim(u)
</pre>
<p>
We use that knowledge to update the tree efficiently during the network simplex iterations.
</p>
<pre class="example">
a === b === c === d ==== h
 \--------- f === g ===/
  \-------- e ===/
</pre>
<p>
If we decide that our entering edge is <code>a--e</code>, then we have to walk the <b>parent</b>
edges until we find the least common ancestor <code>l</code>. All edges we traversed have to be updated.
The least common ancestor <code>l</code> is the node that satisfies:
</p>
<pre class="example">
low(l) less or equal lim(a) and lim(e) less equal lim(l).
</pre>
<p>
In our case this will <code>h</code>. So we have to update all edges but <code>f--g</code>.
</p>

<p>
The paper suggests that when choosing an edge with negative-cut value, we shouldn't always take the
first but search cyclically through. Not sure what they exactly mean,
but we could try just choosing one at random.
</p>

<p>
Puh! I have a feeling without a nice graph traversal framework, it's gonna be a pain implementing this.
In Part 3 we continue with <code>Vertex Ordering within Ranks</code>.
</p>
</div>
</div>
</div>
</div>
</div>

    </div>
</div>

        <div>
        <div class="post-meta">
            <span title="post date" class="post-info">2016-05-30</span>
            <span title="last modification date" class="post-info">2016-05-30</span>
            <span title="tags" class="post-info"><a href="/tags/emacs/">Emacs</a>, <a href="/tags/ascii/">ascii</a>, <a href="/tags/graph/">graph</a>, <a href="/tags/emaci/">emaci</a>, <a href="/tags/lisp/">lisp</a></span>
            <span title="author" class="post-info">David Zuber</span>
        </div>
        <section>
            <h1>Comments</h1>
                <div id="disqus_thread"></div>
                <script type="text/javascript">
                 //var disqus_developer = 1;
                 var disqus_identifier = "/blog/2016/05/30/drawing-a-directed-graph-with-ascii-characters-in-emacs-(part-2)";
                 var disqus_url = "https://storax.github.io/blog/2016/05/30/drawing-a-directed-graph-with-ascii-characters-in-emacs-(part-2)";
                 var disqus_shortname = 'storaxgithubio';
                 /* * * DON'T EDIT BELOW THIS LINE * * */
                 (function() {
                     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                     dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                 })();
                </script>
                <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                <a href="//disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </section>
    <script src="//code.jquery.com/jquery-latest.min.js"></script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.x (<a href="http://orgmode.org">Org mode</a> 8.x)</p>
        <p>
            Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:zuber &lt;dot&gt; david &lt;at&gt; gmx &lt;dot&gt; de">David Zuber</a>
            &nbsp;&nbsp;-&nbsp;&nbsp;
            Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
            <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
    </div>
</div>

    </body>
</html>
