#+TITLE:       Drawing a directed graph with ASCII-characters in Emacs (Part 2)
#+AUTHOR:      David Zuber
#+EMAIL:       zuber.david@gmx.de
#+DATE:        2016-05-30 Mo
#+URI:         /blog/%y/%m/%d/drawing-a-directed-graph-with-ascii-characters-in-emacs-(part-2)
#+KEYWORDS:    Emacs,ascii,graph,emaci,lisp
#+TAGS:        :Emacs:ascii:graph:emaci:lisp:
#+LANGUAGE:    en
#+OPTIONS:     H:6 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: The ranking algortihm.

In [[http://storax.github.io/blog/2016/05/29/drawing-a-directed-graph-with-ascii-characters-in-emacs/][part 1]] I started researching on how to implement an algorithm for drawing directed graphs
in Emasc.

* The ranking algorithm
#+BEGIN_SRC emacs-lisp
  (defun rank ()
    (feasible-tree)
    (let (e)
      (while (setq e (leave-edge))
        (exchange e (enter-edge e))))
    (normalize)
    (balance))
#+END_SRC
The ranking algorithm stats with finding a feasible tree
** feasible-tree
#+BEGIN_SRC emacs-lisp
  (defun feasible-tree ()
    (init-rank)
    (while (< (tight-tree) (absolute-value V))
      (let ((e (get-non-tree-node-incident-on-tree-with-min-slack))
            (delta (slack e)))
        (when (eq incident-node (e-head e))
          (setq delta (- delta)))
        (mapc
         (lambda (v) (setf (v-rank v) (+ (v-rank v) delta)))
         tree)))
    (init-cutvalues))
#+END_SRC
Remember =v= is a node, =e= is an edge. Rank is the the level of a node in the graph.
A tight edge has the slack 0. So if the minimal length of an edge is 1, then
the slack is calculated by =(- (length e) minimal-length)= so an edge with length 1 would have a slack of zero,
thus being tight.

*** init-rank
The paper won't go into detail for brevity (sigh).
They use a queue.
You go through all nodes and place a node in the queue when they have no unscanned in-edges.
So the first nodes would be the ones without any in-edges.
#+BEGIN_EXAMPLE
a -- b -- d
  \-----/
#+END_EXAMPLE
In the above graph a has no unscanned in-edges. All edges so far are unscanned.
So we assign a rank that satisfies the in-edges. Since there are no edges, we use 0.
Then we mark the outedges as scanned:
#+BEGIN_EXAMPLE
a0 == b -- d
 \========/
#+END_EXAMPLE
So an equal sing declares an edge as marked. =a= has been assigned rank 0.
We check our remaining nodes for candidates for the queue.
=d= has an unscanned in-edge (=b--d=). But =b= is good.
So we assign =b= a rank that satisfies the in edges.
The edge connects to =a= wich already has a rank 0. So to satisfy it =b= gets 1.
Then we mark out-edges as scanned.
#+BEGIN_EXAMPLE
a0 == b1 == d
 \=========/
#+END_EXAMPLE
Now d has no unscanned in-edges anymore so we put it in the queue.
On in edge goes to =a= which has rank 0 and one goes to =b= with rank 1.
So to satisfy both we need the maximum plus 1. So =d= gets rank 2.
The final result of =init-rank= is:
#+BEGIN_EXAMPLE
a0 == b2 == d3
 \=========/
#+END_EXAMPLE

*** tight-tree
So according to the paper =tight-tree= finds a maximal tree of tight edges containing some fixed node
and returns the number of nodes in the tree.
So for this we disregard directions and use an undirected graph.
We choose a random node, e.g. =a=, and traverse the tree in all directions using tight edges.
#+BEGIN_EXAMPLE
a -- b -- c -- d -- f -- g
 \        i --/         /
  \----------- h ------/
#+END_EXAMPLE
Not sure if this is what the paper means exactly. I guess my example would not occur
after =init-rank= but whatever.
So we pick a random node =a=. Using only tight edges =--= the tight tree is:
#+BEGIN_EXAMPLE
a -- b -- c -- d -- f -- g
          i --/
#+END_EXAMPLE
=h= is not part of the tight tree.
When the number of nodes in the tight tree is the same as number of nodes in the graph,
the while loop terminates. Then every node is connected to another by at least one
thight edge.
*** while body
We take a non tree edge incident on the tree with minimal slack.
Allright, so we check each edge of our tree nodes and see if they go to a node that's not in the tree.
=a -- b= is a tree edge but =a -- h= is not. The slack is 2 (length is 3, minus minimal lenght 1 equals 2).
=h -- g= is also not a tree edge but the slack is 1 (length is 2, minus minimal length 1 equals 1).
So we take the edge with minal slack =h -- g=.
=delta= is the slack value 1.
If the incident node is the head, delta should be inverted.
The incident node is =g= (I guess) and it's the head.
So the rank of all nodes in the tree is decreased by 1.
#+BEGIN_EXAMPLE
a -- b -- c -- d -- f -- g
 \        i --/         /
  \---------------- h -/
#+END_EXAMPLE
As we can see, =h= is now connected with a tight edge to =g=.
Also note that =a= has a rank of =-1=. That's why we need to normalize the graph afterwards.
Now all nodes are in the tight tree. We can caluclate this faster by
taking the tight-tree of =h= before the move and adding all the nodes to the tight tree.

*** init-cutvalues
This took a while until I fully understood what the paper was trying to say.
Also it's gonna get complicated calculating this without a very dumb algorithm.
The paper has some suggestions but they seem more complex than the other stuff.

So this computes the cut values of tree edges.
We iterate over the edges and mark nodes belonging to the head or tail component.
It's important that we keep in mind, which edges are tree edges.
Consider a graph like this
#+BEGIN_EXAMPLE
a =3= b =3= c =3= d =3== h
 \--------- f =0= g =-1=/
  \-------- e =0=/
#+END_EXAMPLE
where the numbers indicate the cut values.
How does it work.
We cut the graph at an edge. Let's take =g--h=.
We have a head component starting from =h=:
#+BEGIN_EXAMPLE
a == b == c == d == h
#+END_EXAMPLE
and the tail component
#+BEGIN_EXAMPLE
f == g
e ==/
#+END_EXAMPLE
Now we sum the signed weight of all edges that have head and tail in different components.
The sign is negative for edges going from the head component to the tail.
So the first edge that has head and tail in different components is the edge we just cut.
It goes from tail to head so the value so far is 1.
But edges =a--f= and =a--e= also have head and tail in different components.
They go from the head component to the tail component.
So we have to negate their weights. The final sum and cut value is =1+(-1)+(-1)=2=.
So with our two cut components, any edge from head to tail is considered as
the edge from =enter-edge= (see pseudo code of rank algorithm).
So between =a--f= and =a--e= the one with the minimal slack is chosen. Both have the same slack
so we choose at random =a--e=.
The edges are exchanged so =g--h= now has the length of 2 and =a--e= 1.
Note that =g--h= and =a--f= are not part of the tree but =a--e= is.
Not quite sure yet how the exchange happends, but ranks have to be adjusted as well as the cut values.
The new rank of =e= has to be 0 (note that =a= is -1), same as f.
=g= is now of rank 1 instead of 2.
#+BEGIN_EXAMPLE
a ==2= b =2= c =2=d =2= h
 \---- f =0= g --------/
  \=1= e =1=/
#+END_EXAMPLE
My guess is that the whole tail component is adjusted, by the amount of slack transfer.
I have to think about it more. But now it's 4 o'clock at night, so I'll sleep over it.

Good morning! Alright, so reading through the implementation details, we first should
cut values of edges connecting to a leaf node. It's trivial because either head or tail component has
only one node.
#+BEGIN_EXAMPLE
a -- b -- c -- d -- e
 \   f --/         /
  \---------------/
#+END_EXAMPLE
So a leaf node is all nodes that have only 1 tight edge.
They can have non-tree edges.
If we cut the tight edge, either head or tail is only 1 node.
In this case =a--b=, =d--e= and =f--c=.
The cut value is calculated by looking at the edges connecting to the single node.
If the node is the tail, out-going edges are signed positive, in-going ones are negative.
If the node is the head, in-going edges are positive, out-going ones negative.
#+BEGIN_EXAMPLE
cutvalue = (if tail + else -) out-going + (if tail - else +) in-going.
#+END_EXAMPLE
So with =f--c=, =f= is a tail node. That means outgoing ones are positive, giving it the value
of 1.
Cutting =a--b= will render =a= as a tail node. It has 2 outgoing edges so the cut value is 2.
When cutting =d--e=, e is a head node. This will make in going edges positive.
Since there are 2, the cut value is 2 as well.

**** Optimization by using only local edges.
The following part was a little bit confusing because it only showed the term
for one example. It did not give any rules, how the term was constructed.
The point the paper is trying to make is, that if you have a node, where
all cut values of tree edges are known, except for 1, you can calculate the cutvalue
with only looking at the edges connecting with that node.
The rules are the following:

- start with the weight of the edge with unknown cut value (should be 1 in our case).
- all non-tree egdes going out increment it by their weight (a.k.a. 1).
- all non-tree edges going in decrement it by their weight.
- for tree edges add their cut value but subtract their weight.

This works only when doing it incrementally.
We take the graph from above:
#+BEGIN_EXAMPLE
a === b == c == d == h
 \--- f == g -------/
  \== e ==/
#+END_EXAMPLE
If we start with =h=, we could calculate the trivial solution and get 2.
Next we calculate another leaf =f= and get 0.
#+BEGIN_EXAMPLE
a === b === c == d =2= h
 \--- f =0= g --------/
  \== e ===/
#+END_EXAMPLE
Now our incremental algorithm takes over.
We need a node with only 1 unkown tree edge.
=d= and =g= are good candidates.
Let's take =d= and calculate the unknown =c--d= cut value.
It has one tree edge with cut value 2 and weight 1.
Also we need the weight of =c--d= which is 1.
#+BEGIN_EXAMPLE
cut(c,d) = w(c,d) + cut(d,h) - w(d,h)
         = 1      + 2        - 1
         = 2
#+END_EXAMPLE
Alright. Result is now this:
#+BEGIN_EXAMPLE
a === b === c =2= d =2= h
 \--- f =0= g ---------/
  \== e ===/
#+END_EXAMPLE
Next we do the same with =c= and then =b= getting to this:
#+BEGIN_EXAMPLE
a =2= b =2= c =2= d =2= h
 \--- f =0= g ---------/
  \== e ===/
#+END_EXAMPLE
Not time for =g=. The unknown edge is =e--g= with weight 1.
We have 1 outgoing non-tree edge and another tree edge.
#+BEGIN_EXAMPLE
cut(e,g) = w(e,g) + w(g,h) + cut(f,g) - w(f,g)
         = 1      + 1      + 0        - 1
         = 1
#+END_EXAMPLE
Notice how outgoing non-tree edges are positive.
Weights of tree egdes are always negative while their cut value is positive.
#+BEGIN_EXAMPLE
a =2= b =2= c =2= d =2= h
 \--- f =0= g ---------/
  \== e =1=/
#+END_EXAMPLE
Last but not least we look at =e= and the unknown edge =a--e=.
#+BEGIN_EXAMPLE
cut(a,e) = w(a,e) + cut(e,g) - w(e,g)
         = 1      + 1        - 1
         = 1
#+END_EXAMPLE
Final initial cut values are:
#+BEGIN_EXAMPLE
a ==2= b =2= c =2= d =2= h
 \---- f =0= g ---------/
  \=1= e =1=/
#+END_EXAMPLE

I hope this is correct. At least it's consistent with the paper. Not sure if it makes any sense,
but I feel like I understood it finally.
Sadly we are not done with optimizing.
**** Optimization by labeling with postorder traversal
It provides an inexpensive way to test, which nodes are in the head or in the tail.
It's important for knowing if a nontree edge crosses between the two components.
We do a postorder traversal starting from a fixed root node.
Each node gets labeld with =low(v)= and =lim(v)=.
We start with both being 1.
In a tree we always take the left branch first, labeling the node we pass with the current =low= and =lim=
values. The =low= will always stay set on the node.
Once we cannot go deeper, we have to go back inceasing current =low= and =lim= by one.
The next node we encounter get's set it's =lim= but not =low= because it's already set.
We continue doing that:
#+BEGIN_EXAMPLE
               (1,1)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     ( , )            ____( , )____
    /     \         _/      |      \_
   /       \       /        |        \
( , )     ( , ) ( , )     ( , )     ( , )
                  |
                  |
                ( , )

               (1,1)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,1)            ____( , )____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     ( , ) ( , )     ( , )     ( , )
                  |
                  |
                ( , )
#+END_EXAMPLE
Now we reached a dead end, so we increase =low= and =lim=.
#+BEGIN_EXAMPLE
               (1,1)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,2)            ____( , )____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     ( , ) ( , )     ( , )     ( , )
                  |
                  |
                ( , )

               (1,1)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,2)            ____( , )____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     (2,2) ( , )     ( , )     ( , )
                  |
                  |
                ( , )
#+END_EXAMPLE
Note that =low= never changed because it keeps the lowest value.
Another dead end so again increase =low= and =lim=.
#+BEGIN_EXAMPLE
               (1,4)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,3)            ____( , )____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     (2,2) ( , )     ( , )     ( , )
                  |
                  |
                ( , )
#+END_EXAMPLE
We had to go up twice so =lim(root)= is now 4.
#+BEGIN_EXAMPLE
               (1,4)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,3)            ____(4,4)____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     (2,2) (4,4)     ( , )     ( , )
                  |
                  |
                (4,4)

               (1,4)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,3)            ____(4,6)____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     (2,2) (4,5)     ( , )     ( , )
                  |
                  |
                (4,4)

               (1,4)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,3)            ____(4,6)____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     (2,2) (4,5)     (6,6)     ( , )
                  |
                  |
                (4,4)

               (1,4)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,3)            ____(4,7)____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     (2,2) (4,5)     (6,6)     (7,7)
                  |
                  |
                (4,4)

               (1,9)
             _/     \_
           _/         \_
         _/             \_
        /                 \
     (1,3)            ____(4,8)____
    /     \         _/      |      \_
   /       \       /        |        \
(1,1)     (2,2) (4,5)     (6,6)     (7,7)
                  |
                  |
                (4,4)
#+END_EXAMPLE

So how do we determine head or tail components.
Let's take the edge with the node =(1,3)= to =(1,1)=.
Let's call them =u= and =v=.
Any node is in the tail component if and only if
#+BEGIN_EXAMPLE
low(u) less or equal lim(w) less or equal lim(u)
#+END_EXAMPLE
We use that knowledge to update the tree efficiently during the network simplex iterations.
#+BEGIN_EXAMPLE
a === b === c === d ==== h
 \--------- f === g ===/
  \-------- e ===/
#+END_EXAMPLE
If we decide that our entering edge is =a--e=, then we have to walk the *parent*
edges until we find the least common ancestor =l=. All edges we traversed have to be updated.
The least common ancestor =l= is the node that satisfies:
#+BEGIN_EXAMPLE
low(l) less or equal lim(a) and lim(e) less equal lim(l).
#+END_EXAMPLE
In our case this will =h=. So we have to update all edges but =f--g=.

The paper suggests that when choosing an edge with negative-cut value, we shouldn't always take the
first but search cyclically through. Not sure what they exactly mean,
but we could try just choosing one at random.

Puh! I have a feeling without a nice graph traversal framework, it's gonna be a pain implementing this.
In Part 3 we continue with =Vertex Ordering within Ranks=.
